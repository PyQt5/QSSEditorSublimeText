#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on 2022/05/26
@author: Irony
@site: https://pyqt.site https://github.com/PyQt5
@email: 892768447@qq.com
@file: Client.py
@description:
"""

import asyncio
import functools
import json
import logging
import uuid
from threading import Thread
from time import sleep

import sublime
import websocket

from qsseditor.Utils import PLUGIN_NAME, get_setting

logger = logging.getLogger(PLUGIN_NAME)


class QSSEditorClient(Thread):

    Client = None
    Loop = None
    Completions = []

    async def async_loop():
        """async循环，等待异步任务"""
        while 1:
            if not QSSEditorClient.Loop:
                logger.debug('async loop thread end')
                break
            if QSSEditorClient.Loop.is_running():
                await asyncio.sleep(0.2)
            else:
                logger.debug('async loop thread end')
                break

    def async_main():
        logger.info('main async loop thread started')
        try:
            QSSEditorClient.Loop.run_until_complete(
                QSSEditorClient.async_loop())
        except Exception as e:
            logger.error(str(e))
        for task in asyncio.all_tasks():
            task.cancel()

    def __init__(self, *args, **kwargs):
        super(QSSEditorClient, self).__init__(*args, **kwargs)
        logger.debug('QSSEditorClient::__init__')
        self.setDaemon(True)
        self.m_ws = None
        self.m_valid = True
        self.m_task = None
        if QSSEditorClient.Loop is None:
            logger.info('get current event loop')
            QSSEditorClient.Loop = asyncio.get_event_loop()
            Thread(target=QSSEditorClient.async_main, daemon=True).start()

    def setValid(self, valid):
        self.m_valid = valid

    def applyStyleAsync(self, view):
        if self.m_task:
            self.m_task.cancel()
        self.m_task = asyncio.ensure_future(self._applyStyle(view))

    async def _applyStyle(self, view):
        await asyncio.sleep(2)
        self.applyStyle(view)

    def applyStyle(self, view=None):
        try:
            if view is None:
                view = sublime.active_window().active_view()

            # 获取选中的内容
            styleSheets = [
                view.substr(sublime.Region(region.a, region.b))
                for region in view.sel()
                if not region.empty()
            ]
            styleSheets = [
                text for text in styleSheets
                if text.strip().strip('\r').strip('\n')
            ]

            if len(styleSheets) == 0:
                # 获取全部内容
                styleSheets.append(view.substr(sublime.Region(0, view.size())))

            if len(styleSheets) == 0:
                return

            self._sendMessage('setStyleSheet', styleSheets, True)
        except Exception as e:
            logger.warn(str(e))

    def _sendMessage(self, method, params, notify=False):
        """
        发送json-rpc消息
        :param method: 方法名
        :param params: 参数
        :param notify: 是否通知
        """
        if self.m_valid and self.m_ws:
            message = {
                'jsonrpc': '2.0',
                'method': method,
                'params': params,
            }
            if not notify:
                message['id'] = str(uuid.uuid1())
            self.m_ws.send(json.dumps(message))

    def _onHandler(self, method, params):
        """
        处理消息
        :param method: 方法名
        :param params: 参数
        """
        if method == 'addKeywords':
            if not params or not isinstance(params, list):
                return
            for word in params:
                QSSEditorClient.Completions.append(
                    sublime.CompletionItem(
                        trigger=word,
                        completion=word,
                        completion_format=sublime.COMPLETION_FORMAT_TEXT,
                        kind=sublime.KIND_MARKUP))

    def _onMessage(self, ws, message):
        """
        接收消息
        :param ws: websocket
        :param message: 消息
        """
        logger.debug('client received message: {}'.format(message))
        try:
            message = json.loads(message)
            self._onHandler(message.get('method', ''),
                            message.get('params', []))
        except Exception as e:
            logger.warn(str(e))

    def _onError(self, ws, error):
        """
        错误处理
        :param ws: websocket
        :param error: 错误
        """
        logger.warn(str(error))

    def _onClose(self, *args):
        """连接关系"""
        logger.debug('client disconnected')

    def _onOpen(self, ws):
        """
        连接成功
        :param ws: websocket
        """
        logger.debug('client connected')

    def run(self):
        logger.info('client started')
        while self.m_valid:
            port = get_setting(None, 'server_port', 61052)
            logger.debug('client start to connect 127.0.0.1:{}'.format(port))
            try:
                self.m_ws = websocket.WebSocketApp(
                    'ws://127.0.0.1:{}'.format(port),
                    on_open=self._onOpen,
                    on_message=self._onMessage,
                    on_error=self._onError,
                    on_close=self._onClose,
                )
                self.m_ws.run_forever(ping_interval=60, ping_timeout=30)
            except KeyboardInterrupt:
                break
            except Exception as e:
                logger.warn(str(e))
                logger.debug('client will reconnect')

            if not self.m_valid:
                break
        logger.info('client loop finished')

    def stop(self):
        """关闭客户端"""
        self.setValid(False)
        if self.m_ws:
            self.m_ws.close()
        logger.info('client will stop')
