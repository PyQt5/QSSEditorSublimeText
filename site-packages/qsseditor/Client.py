#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on 2022/05/26
@author: Irony
@site: https://pyqt.site https://github.com/PyQt5
@email: 892768447@qq.com
@file: Client.py
@description:
"""

import asyncio
import functools
import json
import logging
from threading import Thread
from time import sleep

import sublime
import websockets
from jsonrpcclient import request_json
from websockets.connection import CLOSED, CLOSING

from qsseditor.Utils import PLUGIN_NAME, get_setting

logger = logging.getLogger(PLUGIN_NAME)


class QSSEditorClient(Thread):

    Client = None
    Completions = []

    def __init__(self, *args, **kwargs):
        super(QSSEditorClient, self).__init__(*args, **kwargs)
        logger.debug('QSSEditorClient::__init__')
        self.setDaemon(True)
        self.m_ws = None
        self.m_valid = True
        self.m_closed = False
        self.m_task = None
        self.m_loop = asyncio.get_event_loop()

    def setValid(self, valid):
        self.m_valid = valid

    def applyStyleAsync(self, view, delay=False):
        logger.debug('applyStyleAsync')
        if self.m_closed or not self.m_valid:
            return
        if self.m_task:
            self.m_task.cancel()
        if delay:
            self.m_task = asyncio.ensure_future(self.applyStyle(view),
                                                loop=self.m_loop)
        else:
            asyncio.run_coroutine_threadsafe(self.applyStyle(view), self.m_loop)

    async def applyStyle(self, view=None):
        logger.debug('applyStyle')
        try:
            if view is None:
                view = sublime.active_window().active_view()

            # 获取选中的内容
            styleSheets = [
                view.substr(sublime.Region(region.a, region.b))
                for region in view.sel()
                if not region.empty()
            ]
            styleSheets = [
                text for text in styleSheets
                if text.strip().strip('\r').strip('\n')
            ]

            if len(styleSheets) == 0:
                # 获取全部内容
                styleSheets.append(view.substr(sublime.Region(0, view.size())))

            if len(styleSheets) == 0:
                return

            await self.m_ws.send(
                request_json('setStyleSheet', params=styleSheets))
        except Exception as e:
            logger.warn(str(e))

    async def onHandler(self, method, params):
        if method == 'addKeywords':
            if not params or not isinstance(params, list):
                return
            for word in params:
                QSSEditorClient.Completions.append(
                    sublime.CompletionItem(
                        trigger=word,
                        completion=word,
                        completion_format=sublime.COMPLETION_FORMAT_TEXT,
                        kind=sublime.KIND_MARKUP))

    async def _run(self):
        while self.m_valid:
            try:
                # 连接服务端
                self.m_ws = await websockets.connect('ws://127.0.0.1:{}'.format(
                    get_setting(None, 'server_port', 61052)))
                logger.info('connect successfully')
                # 接收消息
                while self.m_valid:
                    try:
                        response = json.loads(await self.m_ws.recv())
                        await self.onHandler(response.get('method', ''),
                                             response.get('params', []))
                    except Exception as e:
                        logger.error(str(e))
                        if self.m_ws.state in (CLOSING, CLOSED):
                            logger.info('connection is closed')
                            break
                if self.m_closed:
                    break
            except Exception as e:
                logger.error(str(e))

            if self.isRunning():
                await asyncio.sleep(3)

        logger.info('client is finished')

    def run(self):
        if self.isRunning():
            return
        logger.info('client started')
        try:
            self.m_loop.run_until_complete(self._run())
        except Exception as e:
            logger.warn(str(e))
        logger.info('client loop finished')

    def stop(self):
        self.m_closed = True
        self.setValid(False)
        asyncio.run_coroutine_threadsafe(self.m_ws.close(), self.m_loop)
        self.m_loop.stop()
        logger.info('client will stop')

    def isRunning(self):
        return self.m_loop.is_running()
